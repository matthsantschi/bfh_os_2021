#include <stdio.h>
#include <stdlib.h>
#include "memory_management.h"

int nb_processes;
int ff_nb;
int vpn_len;
int offset_len;
int tlb_max_len;

struct TLB_entry{
  int pid;
  int page;
  int frame;
  struct TLB_entry* next;
};

struct free_frame{
  int frame;
  struct free_frame* next;
};

struct TLB_entry* tlb;
struct free_frame* free_frames_list;
int tlb_size;

int** page_table_array;

int insert_free_frame(int frame)
{
  struct free_frame* ptr_free_frame = (struct free_frame*)
    malloc (sizeof(struct free_frame*));

  ptr_free_frame->frame = frame;
  ptr_free_frame->next = free_frames_list;
  free_frames_list = ptr_free_frame;
  
  return 0;
}


int get_free_frame(int* ptr_frame)
{
  struct free_frame* ptr_free_frame = free_frames_list;
  if(NULL == ptr_free_frame)
    {
      return 1;
    }
  *ptr_frame = ptr_free_frame->frame;
  free_frames_list = free_frames_list->next;
  free(ptr_free_frame);
  return 0;
}

int memory_init_data(int number_processes,
		     int free_frames_number,
		     int length_VPN_in_bits,
		     int length_PFN_in_bits,
		     int length_offset_in_bits,
		     int tlb_size)                
{
  nb_processes = number_processes;
  ff_nb =free_frames_number;
  vpn_len = length_VPN_in_bits;
  offset_len=length_offset_in_bits;
  tlb_max_len=tlb_size;

  page_table_array=(int**)malloc(sizeof(int*)*number_processes);
  for(int i = 0; i<number_processes;i++)
    {
      int nb_pages = 1<<length_VPN_in_bits;
      // printf("nb_pages = %d, length = %d\n",nb_pages,length_VPN_in_bits);
      page_table_array[i]=(int*) malloc(sizeof(int)*nb_pages);
      for(int j = 0; j< nb_pages ; j++)
	{
	  page_table_array[i][j]=-1;
	}
      
  }
  tlb = NULL;
  tlb_size = 0;
  free_frames_list = NULL;
  for(int j = 0; j < free_frames_number; j++)
    {
      insert_free_frame(j);
    }

  
return 0;
}


uint64_t generate_mask(int length)
{
  uint64_t mask=0;
  for(int i=0; i<length;i++)
    {
      mask = mask<<1;
      mask +=1;
    }
  return mask;
}



struct TLB_entry* get_TLB_entry(int page_number,int pid)
{
  struct TLB_entry* ptr = tlb;
  while(NULL != ptr)
    {
      if(page_number == ptr->page &&
	 pid == ptr->pid){
	return ptr;
      }
      ptr = ptr->next;
    }
  return NULL;
}

int insert_TLB_entry(int page_number, int pid, int frame_number)
{
  struct TLB_entry * ptr = (struct TLB_entry*) malloc(sizeof(struct TLB_entry));
  ptr->page = page_number;
  ptr->pid = pid;
  ptr->frame = frame_number;
  ptr->next = tlb;
  tlb = ptr;
  
  if(tlb_size == tlb_max_len)
    {
      if(1 == tlb_max_len)
	{
	  tlb->next=NULL;
	}
      else
	{
	  while(NULL != ptr->next->next){
	    ptr = ptr->next;
	  }
	  struct TLB_entry * tobedeleted = ptr->next;
	  ptr->next = NULL;
	  free(tobedeleted);
	}
    }
  else
    {
       tlb_size += 1;
    }
}


int get_physical_address(uint64_t virtual_address,
			 int process_id,
			 uint64_t* physical_address,
			 int* tlb_hit)
{
  int page_number = virtual_address >> offset_len;
  int overflow = page_number >> vpn_len;
  if(0 != overflow){
    return 1; // The address is too long
  }
  struct TLB_entry* ptr_tlb_entry = get_TLB_entry(page_number,process_id);
  int frame;
  if(NULL != ptr_tlb_entry)
    {
      frame = ptr_tlb_entry->frame;
      *tlb_hit = 1;
    }
  else // Case where the element is not in the TLB
    {
      *tlb_hit = 0;
      frame = page_table_array[process_id][page_number];
      // printf("table [%d][%d] -> %d\n",process_id,page_number,frame);
      if(-1 == frame)
	{
	  int res = get_free_frame(&frame);
	  if(0 != res) // no free frame available
	    {
	      return 2;
	    }
	  // printf("we receive new frame %#x\n",frame);
	}
      
      insert_TLB_entry(page_number, process_id,frame);
    }
  uint64_t mask = generate_mask(offset_len);
  uint64_t offset = virtual_address & mask;
  // printf("we receive new frame %#x\n",frame);
  *physical_address = (frame << offset_len) | offset;
  // printf("frame = %#x, mask = %#lx, offset =%#lx, physical address =%#lx\n",frame,mask,offset,*physical_address);
  return 0;
}

